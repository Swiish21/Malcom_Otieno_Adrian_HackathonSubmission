File 1: LongestSubstrWithoutRepeatingChar, here the challenge was to write a function that finds the length of the longest substring without repeating characters. we begin by defining a function with a string(s) parametre, the function is supposed to return an int value(the length of the substring), we define 3 variables 'char_set', 'left' and 'max_length', they are used to: (char_set)- create an empty set to hold the substring, (left)- to represent the starting index of the substring, (max_length)- to hold the int value for the length of the substring. We use a for loop to iterate through the string  checking the characters, in the for loop we use a nested while loop to check if the current character is already in the substring(each iterration of the for loop), if it is we remove it from the substring, if not we add it to the substring. with each iterration we update the max_length, until we reach the end of the string. finally we return the length of the longest substring,  we finish by getting user input(s) for the string to be checked, we then print the length of the longest substring for the user to see. 

File 2: regularExpressionMatching.py, the challenge was to imprement as function that supports regular expression matching with support for . and * , we begin by defining the function and assigning it two parametres text and pattern, text is for the input text to be checked and pattern parameter will hold the regex, the function is supposed to return a boolean value of either true or false. Now we need to deal with a few cases for our program to function as intended, the first case is where we have an empty pattern(no regex is present), we use an if statement to show that if the pattern is empty, it means that the text has to also be empty for it to match and return true, else it will return false. The next casewe deal with the case where the first character of the text matches the first character of the pattern, we also added a case where if the first charcter is (.) it will match. The final case covers a situation where the pattern has atleast two characters and the second character is a wildcard *, it checks two possibilities, (I) the wildcard matches zero occurences of the preceeding characters, so it recursively calls 'is_match' with the rest of the pattern 'pattern[2:]' and the origininal text. (II) the wildcard * matches one or more occurences of the preceeding character, so it recursively calls 'is_match' with the rest of the text 'text[1:]' and the original pattern. Else: if the pattern doesnt have * as it's second character, it simply checks the first character of the text, matches it with the first character of the pattern the recursively calls 'is_match' with the rest of the text and pattern. We present some simple text cases to test our program.